== Step 4: Dealing

. **ALL PREVIOUS REQUIREMENTS MUST WORK**
. If we do not detect scenario files we deal.
. If relevant input params were passed we also deal.
. Deck should be shuffled. Shuffling should be pseudorandom (some repetitions in the shuffled deck are fine, too many are not - we suggest to learn the `Random` class' API).
. Cards should be randomly distributed to all players.
. First player to get a card is player1, then 2 etc.
. It's possible that some players will get LESS cards than others! E.g. 52 cards, 5 players, all get 10 cards, 2 remaining cards will be distributed to player1 and player2.
. LUCKY PLAYERS are those who received extra card and are written in the order of dealing (player1 is always first).

=== Players?

Launching game with 4 players causes the deck to be split between 4 players. 

Players have no name, just monikers formatted so: **playerX**, where X is a number between 1-5. 

All players are computer players.

CAUTION: There are no human players at all in this game. It's a so-called zero-player game, computers play against computers. Adding a human player is considered a bonus feature, but one that gives little points.

How you translate that into code is absolutely on you. Rationalize your decisions - if you see the need - via diagrams and `remarks.md` file.

=== Usage

First-timers don't know how to run a program. Old-timers may forget how to run it. Which params to give. In what order. Therefore it's an established tradition that running a program BADLYfootnote:[Read the usage screen. It's quite clear on what should happen when.] should prompt the program into printing the correct usage - or usage for short.

If one wants to see usage:

. one runs with `--help` - this option ONLY runs the usage and quits, no matter the other parameters given!
. one runs program badly

NOTE: If you launch the game WITHOUT parameters, it first picks up scenario files. Only if there's none, the game will actually play on a small deck with 2 players.

CAUTION: Running your program with thousands of params AND `--help` just displays the usage and quits. 

----
include::usage.screen[]
----

Make sure you have a `usage` function that takes care of that (bonus points if it's OO!).

=== Dealing screen

----
include::dealing.screen[]
----

1. Players' hands are printed in brackets: `[]`
2. They are sorted, descendingly.
3. Duplicated values are next to each other: 4, 4, 4...
4. Lucky players are those who received extra card and are written in the order of dealing (player1 is always first). There may be none: then the program should state `none` instead of listing them. Both a list and a `none` end with a dot.
5. SEPARATOR is as defined earlier.


.war_example.json
----
include::war_example.json[]
----

WARNING: Scenario files are NOT staring arguments. You DO NOT pass them via command line.

With a file like that:

. game should start with a small deck and 3 players (there are 24 cards in the file)
. player1 should get a hand with 2 aces, 3 10s and 2 9s and a valet. 
. player2 should get 2 9s, 3 valets, a queen, a king and an ace
. player3 should get the remaining cards in the deck.
. game should begin WITHOUT dealing 
.. dealing is skipped if the special scenario code is present
.. instead a String "special scenario code: CAPITALIZED NAME" of the special scenario is displayed
.. for the file above that would be `EXAMPLE`
.. the name is the `???` part of the file name, so for `ssc_player1_winS_In_7_MoVeS.json` it should be `special scenario code: PLAYER1 WINS IN 7 MOVES`
. BONUS points for CHECKING that the file isn't corrupted
.. not enough cards for a deck
.. too many cards for a deck
.. too many players
.. these should cause a `SpecialCodeFileMangledException`
.. bad _JSON_ syntax should cause a different exception
.. exceptions should have clear error messages, preferably 
... ones allowing to recover, 
... hinting how to fix the file
... e.g. inform the user that SSC has error, which line, what to do about it
. order is preserved: top of the deck for a player begins with the leftmost value (in the example that means 9, 9, 14 are top-most cards

[TIP]
.Why? How? What for?
====
We want you to do that to learn OO design and programming by practicing it. 

You should take into account that testing randomness is difficult and use the special scenario codes to test-drive your implementation of the game.

With this you can have a predictable game - give your players cards and the result should be clear, along with how each turn should look like.

IMPORTANT: We advise you to start with this feature and use it as a test-driving mechanism. Heck, if you will have JSONs that don't show the beginning of the game but jump-start it or offer to bypass early stages that's rather nice - though an extra.

NOTE: One more time, there may be more than one testing scenarios in the `resources` directory! If that's the case, you should run the game multiple times, once per _JSON_ file! And if one of them fails, throw an appropriate exception and move to the next one (if present).
====

== Game output

Game is a sequence of screens:

1. Dealing screen - shows up once,
2. Game screen - shows up multiple times and reflects changes in the game,
3. Duel screen - may be absent, may show up multiple times, if it does, it replaces the game screen for that turn,
4. End screen - shows up once.

IMPORTANT: Every screen of the game is SEPARATED from another screen by a SEPARATOR: **precisely** 9 "=" characters followed by exactly **two** blank lines, so altogether 3 lines of text.

Thus, your game will be outputting screens in the order above.

=== Automated gameplay!

You probably realized that this program is non-interactive. This is a zero-player game: *NO HUMAN* players are needed. User launches the game with two parameters and that's it. The rest is just program executing and printing.

This means:

1. no human interaction,
2. no waiting for humans,
3. no keyboard input,
4. no exception handling - _except_ input parameters of course.

NOTE: The game will stay in this form. There won't be any requirement involved interactivity.
